(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{279:function(e,v,t){"use strict";t.r(v);var s=t(13),o=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"v-model和v-bind-xxx-xx-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-model和v-bind-xxx-xx-的区别"}},[e._v("#")]),e._v(" "),v("code",[e._v("v-model")]),e._v("和"),v("code",[e._v('v-bind(:xxx="xx")')]),e._v("的区别？")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("v-bind")]),e._v("是"),v("strong",[e._v("单向绑定")]),e._v("，只能由Vue实例的属性单向渲染到视图上，如:"),v("code",[e._v('class="xxx"')]),e._v(", "),v("code",[e._v(':class="xxx"')]),e._v(","),v("code",[e._v(':src="xxx"')]),e._v("；")]),e._v(" "),v("li",[v("code",[e._v("v-model")]),e._v("是"),v("strong",[e._v("双向绑定")]),e._v("，可以在视图更新时同时将更新传回属性更新属性，如"),v("code",[e._v("input")]),e._v("，"),v("code",[e._v("textarea")]),e._v("等表单元素可以使用"),v("code",[e._v("v-model")]),e._v("双向绑定来实时更新属性数据。")])]),e._v(" "),v("h2",{attrs:{id:"浏览器缓存和vuex的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存和vuex的区别"}},[e._v("#")]),e._v(" 浏览器缓存和Vuex的区别")]),e._v(" "),v("p",[e._v("缓存在每个组件特定生命周期要存要取，Vuex的state可以直接用，视图可以直接同步；\n状态管理设计的目的并不是用于做缓存，而是用来作为唯一数据源，步状态，共享状态。所以从功能上讲，区别很大。\n你每在一个组件用到storage中的数据，你就要搞一份数据用于同步视图。想想看，直接改storage并不会让视图有任何更新，你必须将storage中的数据parse出来，并且在组件内同步data与storage。并且你在A组件改变storage的数据，并不能让另一个用到其中数据的B组件的数据得到更新。")])])}),[],!1,null,null,null);v.default=o.exports}}]);